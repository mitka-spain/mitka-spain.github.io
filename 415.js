"use strict";(self.webpackChunkinqviz_excel=self.webpackChunkinqviz_excel||[]).push([[415],{56446:function(e,t,r){r.d(t,{sS:function(){return i.sS},m2:function(){return n.m},RZ:function(){return i.RZ},FS:function(){return i.FS},Hh:function(){return s.PromptTemplate},BJ:function(){return i.BJ}});var n=r(46993),i=r(53766);r(62771),n.m;var s=r(23650);r(90329),r(69849),r(76279),i.RZ},19415:function(e,t,r){r.d(t,{LLMChain:function(){return h}});var n=r(42162),i=r(56446),s=r(18687),a=r(7381),l=r(14896);class u extends l.YN{parseResultWithPrompt(e,t,r){return this.parseResult(e,r)}_baseMessageToString(e){return"string"==typeof e.content?e.content:this._baseMessageContentToString(e.content)}_baseMessageContentToString(e){return JSON.stringify(e)}async invoke(e,t){return"string"==typeof e?this._callWithConfig((async(e,t)=>this.parseResult([{text:e}],t?.callbacks)),e,{...t,runType:"parser"}):this._callWithConfig((async(e,t)=>this.parseResult([{message:e,text:this._baseMessageToString(e)}],t?.callbacks)),e,{...t,runType:"parser"})}}class o extends u{parseResult(e,t){return this.parse(e[0].text,t)}async parseWithPrompt(e,t,r){return this.parse(e,r)}_type(){throw new Error("_type not implemented")}}Error,r(53490),r(56362),r(68028),"undefined"!=typeof self&&self.location&&"null"!==self.location.origin&&(self.location.origin,self.location.pathname,location.search);r(14476),r(22522),r(26150),r(30780);class p extends o{constructor(){super(...arguments),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","output_parsers","default"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0})}static lc_name(){return"NoOpOutputParser"}parse(e){return Promise.resolve(e)}getFormatInstructions(){return""}}function c(e){if(function(e){return"function"==typeof e._llmType}(e))return e;if("bound"in e&&s.YN.isRunnable(e.bound))return c(e.bound);if("runnable"in e&&"fallbacks"in e&&s.YN.isRunnable(e.runnable))return c(e.runnable);if("default"in e&&s.YN.isRunnable(e.default))return c(e.default);throw new Error("Unable to extract BaseLanguageModel from llmLike object.")}class h extends a.r{static lc_name(){return"LLMChain"}get inputKeys(){return this.prompt.inputVariables}get outputKeys(){return[this.outputKey]}constructor(e){if(super(e),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"prompt",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"llm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"llmKwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"outputKey",{enumerable:!0,configurable:!0,writable:!0,value:"text"}),Object.defineProperty(this,"outputParser",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.prompt=e.prompt,this.llm=e.llm,this.llmKwargs=e.llmKwargs,this.outputKey=e.outputKey??this.outputKey,this.outputParser=e.outputParser??new p,this.prompt.outputParser){if(e.outputParser)throw new Error("Cannot set both outputParser and prompt.outputParser");this.outputParser=this.prompt.outputParser}}getCallKeys(){return"callKeys"in this.llm?this.llm.callKeys:[]}_selectMemoryInputs(e){const t=super._selectMemoryInputs(e),r=this.getCallKeys();for(const n of r)n in e&&delete t[n];return t}async _getFinalOutput(e,t,r){let n;return n=this.outputParser?await this.outputParser.parseResultWithPrompt(e,t,r?.getChild()):e[0].text,n}call(e,t){return super.call(e,t)}async _call(e,t){const r={...e},n={...this.llmKwargs},i=this.getCallKeys();for(const t of i)t in e&&n&&(n[t]=e[t],delete r[t]);const s=await this.prompt.formatPromptValue(r);if("generatePrompt"in this.llm){const{generations:e}=await this.llm.generatePrompt([s],n,t?.getChild());return{[this.outputKey]:await this._getFinalOutput(e[0],s,t)}}const a=this.outputParser?this.llm.pipe(this.outputParser):this.llm,l=await a.invoke(s,t?.getChild());return{[this.outputKey]:l}}async predict(e,t){return(await this.call(e,t))[this.outputKey]}_chainType(){return"llm"}static async deserialize(e){const{llm:t,prompt:r}=e;if(!t)throw new Error("LLMChain must have llm");if(!r)throw new Error("LLMChain must have prompt");return new h({llm:await n.j_.deserialize(t),prompt:await i.m2.deserialize(r)})}serialize(){const e="serialize"in this.llm?this.llm.serialize():void 0;return{_type:`${this._chainType()}_chain`,llm:e,prompt:this.prompt.serialize()}}_getNumTokens(e){return c(this.llm).getNumTokens(e)}}}}]);
//# sourceMappingURL=415.js.map