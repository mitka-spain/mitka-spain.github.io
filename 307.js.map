{"version":3,"file":"307.js","mappings":"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","sources":["webpack://inqviz-excel/./node_modules/@langchain/core/dist/prompts/base.js","webpack://inqviz-excel/./node_modules/@langchain/core/dist/prompts/prompt.js","webpack://inqviz-excel/./node_modules/@langchain/core/dist/prompts/string.js","webpack://inqviz-excel/./node_modules/@langchain/core/dist/prompts/template.js","webpack://inqviz-excel/./node_modules/@langchain/core/dist/example_selectors/conditional.js","webpack://inqviz-excel/./node_modules/@langchain/core/dist/output_parsers/base.js","webpack://inqviz-excel/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/dereference.js","webpack://inqviz-excel/./node_modules/langchain/dist/output_parsers/noop.js","webpack://inqviz-excel/./node_modules/langchain/dist/chains/llm_chain.js"],"sourcesContent":["// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { Runnable } from \"../runnables/base.js\";\n/**\n * Base class for prompt templates. Exposes a format method that returns a\n * string prompt given a set of input values.\n */\nexport class BasePromptTemplate extends Runnable {\n    get lc_attributes() {\n        return {\n            partialVariables: undefined, // python doesn't support this yet\n        };\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompts\", this._getPromptType()]\n        });\n        Object.defineProperty(this, \"inputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"partialVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const { inputVariables } = input;\n        if (inputVariables.includes(\"stop\")) {\n            throw new Error(\"Cannot have an input variable named 'stop', as it is used internally, please rename.\");\n        }\n        Object.assign(this, input);\n    }\n    /**\n     * Merges partial variables and user variables.\n     * @param userVariables The user variables to merge with the partial variables.\n     * @returns A Promise that resolves to an object containing the merged variables.\n     */\n    async mergePartialAndUserVariables(userVariables) {\n        const partialVariables = this.partialVariables ?? {};\n        const partialValues = {};\n        for (const [key, value] of Object.entries(partialVariables)) {\n            if (typeof value === \"string\") {\n                partialValues[key] = value;\n            }\n            else {\n                partialValues[key] = await value();\n            }\n        }\n        const allKwargs = {\n            ...partialValues,\n            ...userVariables,\n        };\n        return allKwargs;\n    }\n    /**\n     * Invokes the prompt template with the given input and options.\n     * @param input The input to invoke the prompt template with.\n     * @param options Optional configuration for the callback.\n     * @returns A Promise that resolves to the output of the prompt template.\n     */\n    async invoke(input, options) {\n        return this._callWithConfig((input) => this.formatPromptValue(input), input, { ...options, runType: \"prompt\" });\n    }\n    /**\n     * Return a json-like object representing this prompt template.\n     * @deprecated\n     */\n    serialize() {\n        throw new Error(\"Use .toJSON() instead\");\n    }\n    /**\n     * @deprecated\n     * Load a prompt template from a json-like object describing it.\n     *\n     * @remarks\n     * Deserializing needs to be async because templates (e.g. {@link FewShotPromptTemplate}) can\n     * reference remote resources that we read asynchronously with a web\n     * request.\n     */\n    static async deserialize(data) {\n        switch (data._type) {\n            case \"prompt\": {\n                const { PromptTemplate } = await import(\"./prompt.js\");\n                return PromptTemplate.deserialize(data);\n            }\n            case undefined: {\n                const { PromptTemplate } = await import(\"./prompt.js\");\n                return PromptTemplate.deserialize({ ...data, _type: \"prompt\" });\n            }\n            case \"few_shot\": {\n                const { FewShotPromptTemplate } = await import(\"./few_shot.js\");\n                return FewShotPromptTemplate.deserialize(data);\n            }\n            default:\n                throw new Error(`Invalid prompt type in config: ${data._type}`);\n        }\n    }\n}\n","// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport { checkValidTemplate, parseTemplate, renderTemplate, } from \"./template.js\";\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate extends BaseStringPromptTemplate {\n    static lc_name() {\n        return \"PromptTemplate\";\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"template\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.assign(this, input);\n        if (this.validateTemplate) {\n            let totalInputVariables = this.inputVariables;\n            if (this.partialVariables) {\n                totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n            }\n            checkValidTemplate(this.template, this.templateFormat, totalInputVariables);\n        }\n    }\n    _getPromptType() {\n        return \"prompt\";\n    }\n    /**\n     * Formats the prompt template with the provided values.\n     * @param values The values to be used to format the prompt template.\n     * @returns A promise that resolves to a string which is the formatted prompt.\n     */\n    async format(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        return renderTemplate(this.template, this.templateFormat, allValues);\n    }\n    /**\n     * Take examples in list format with prefix and suffix to create a prompt.\n     *\n     * Intended to be used a a way to dynamically create a prompt from examples.\n     *\n     * @param examples - List of examples to use in the prompt.\n     * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n     * @param inputVariables - A list of variable names the final prompt template will expect\n     * @param exampleSeparator - The separator to use in between examples\n     * @param prefix - String that should go before any examples. Generally includes examples.\n     *\n     * @returns The final prompt template generated.\n     */\n    static fromExamples(examples, suffix, inputVariables, exampleSeparator = \"\\n\\n\", prefix = \"\") {\n        const template = [prefix, ...examples, suffix].join(exampleSeparator);\n        return new PromptTemplate({\n            inputVariables,\n            template,\n        });\n    }\n    /**\n     * Load prompt template from a template f-string\n     */\n    static fromTemplate(template, { templateFormat = \"f-string\", ...rest } = {}) {\n        const names = new Set();\n        parseTemplate(template, templateFormat).forEach((node) => {\n            if (node.type === \"variable\") {\n                names.add(node.name);\n            }\n        });\n        return new PromptTemplate({\n            // Rely on extracted types\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            inputVariables: [...names],\n            templateFormat,\n            template,\n            ...rest,\n        });\n    }\n    /**\n     * Partially applies values to the prompt template.\n     * @param values The values to be partially applied to the prompt template.\n     * @returns A new instance of PromptTemplate with the partially applied values.\n     */\n    async partial(values) {\n        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        const newPartialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        const promptDict = {\n            ...this,\n            inputVariables: newInputVariables,\n            partialVariables: newPartialVariables,\n        };\n        return new PromptTemplate(promptDict);\n    }\n    serialize() {\n        if (this.outputParser !== undefined) {\n            throw new Error(\"Cannot serialize a prompt template with an output parser\");\n        }\n        return {\n            _type: this._getPromptType(),\n            input_variables: this.inputVariables,\n            template: this.template,\n            template_format: this.templateFormat,\n        };\n    }\n    static async deserialize(data) {\n        if (!data.template) {\n            throw new Error(\"Prompt template must have a template\");\n        }\n        const res = new PromptTemplate({\n            inputVariables: data.input_variables,\n            template: data.template,\n            templateFormat: data.template_format,\n        });\n        return res;\n    }\n}\n","// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { StringPromptValue, } from \"../prompt_values.js\";\nimport { BasePromptTemplate } from \"./base.js\";\n/**\n * Base class for string prompt templates. It extends the\n * BasePromptTemplate class and overrides the formatPromptValue method to\n * return a StringPromptValue.\n */\nexport class BaseStringPromptTemplate extends BasePromptTemplate {\n    /**\n     * Formats the prompt given the input values and returns a formatted\n     * prompt value.\n     * @param values The input values to format the prompt.\n     * @returns A Promise that resolves to a formatted prompt value.\n     */\n    async formatPromptValue(values) {\n        const formattedPrompt = await this.format(values);\n        return new StringPromptValue(formattedPrompt);\n    }\n}\n","export const parseFString = (template) => {\n    // Core logic replicated from internals of pythons built in Formatter class.\n    // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n    const chars = template.split(\"\");\n    const nodes = [];\n    const nextBracket = (bracket, start) => {\n        for (let i = start; i < chars.length; i += 1) {\n            if (bracket.includes(chars[i])) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    let i = 0;\n    while (i < chars.length) {\n        if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n            nodes.push({ type: \"literal\", text: \"{\" });\n            i += 2;\n        }\n        else if (chars[i] === \"}\" &&\n            i + 1 < chars.length &&\n            chars[i + 1] === \"}\") {\n            nodes.push({ type: \"literal\", text: \"}\" });\n            i += 2;\n        }\n        else if (chars[i] === \"{\") {\n            const j = nextBracket(\"}\", i);\n            if (j < 0) {\n                throw new Error(\"Unclosed '{' in template.\");\n            }\n            nodes.push({\n                type: \"variable\",\n                name: chars.slice(i + 1, j).join(\"\"),\n            });\n            i = j + 1;\n        }\n        else if (chars[i] === \"}\") {\n            throw new Error(\"Single '}' in template.\");\n        }\n        else {\n            const next = nextBracket(\"{}\", i);\n            const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n            nodes.push({ type: \"literal\", text });\n            i = next < 0 ? chars.length : next;\n        }\n    }\n    return nodes;\n};\nexport const interpolateFString = (template, values) => parseFString(template).reduce((res, node) => {\n    if (node.type === \"variable\") {\n        if (node.name in values) {\n            return res + values[node.name];\n        }\n        throw new Error(`Missing value for input ${node.name}`);\n    }\n    return res + node.text;\n}, \"\");\nexport const DEFAULT_FORMATTER_MAPPING = {\n    \"f-string\": interpolateFString,\n};\nexport const DEFAULT_PARSER_MAPPING = {\n    \"f-string\": parseFString,\n};\nexport const renderTemplate = (template, templateFormat, inputValues) => DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\nexport const parseTemplate = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);\nexport const checkValidTemplate = (template, templateFormat, inputVariables) => {\n    if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n        const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n        throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n    }\n    try {\n        const dummyInputs = inputVariables.reduce((acc, v) => {\n            acc[v] = \"foo\";\n            return acc;\n        }, {});\n        renderTemplate(template, templateFormat, dummyInputs);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }\n    catch (e) {\n        throw new Error(`Invalid prompt schema: ${e.message}`);\n    }\n};\n","/**\n * Abstract class that defines the interface for selecting a prompt for a\n * given language model.\n */\nexport class BasePromptSelector {\n    /**\n     * Asynchronous version of `getPrompt` that also accepts an options object\n     * for partial variables.\n     * @param llm The language model for which to get a prompt.\n     * @param options Optional object for partial variables.\n     * @returns A Promise that resolves to a prompt template.\n     */\n    async getPromptAsync(llm, options) {\n        const prompt = this.getPrompt(llm);\n        return prompt.partial(options?.partialVariables ?? {});\n    }\n}\n/**\n * Concrete implementation of `BasePromptSelector` that selects a prompt\n * based on a set of conditions. It has a default prompt that it returns\n * if none of the conditions are met.\n */\nexport class ConditionalPromptSelector extends BasePromptSelector {\n    constructor(default_prompt, conditionals = []) {\n        super();\n        Object.defineProperty(this, \"defaultPrompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"conditionals\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.defaultPrompt = default_prompt;\n        this.conditionals = conditionals;\n    }\n    /**\n     * Method that selects a prompt based on a set of conditions. If none of\n     * the conditions are met, it returns the default prompt.\n     * @param llm The language model for which to get a prompt.\n     * @returns A prompt template.\n     */\n    getPrompt(llm) {\n        for (const [condition, prompt] of this.conditionals) {\n            if (condition(llm)) {\n                return prompt;\n            }\n        }\n        return this.defaultPrompt;\n    }\n}\n/**\n * Type guard function that checks if a given language model is of type\n * `BaseLLM`.\n */\nexport function isLLM(llm) {\n    return llm._modelType() === \"base_llm\";\n}\n/**\n * Type guard function that checks if a given language model is of type\n * `BaseChatModel`.\n */\nexport function isChatModel(llm) {\n    return llm._modelType() === \"base_chat_model\";\n}\n","import { Runnable } from \"../runnables/index.js\";\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nexport class BaseLLMOutputParser extends Runnable {\n    /**\n     * Parses the result of an LLM call with a given prompt. By default, it\n     * simply calls `parseResult`.\n     * @param generations The generations from an LLM call.\n     * @param _prompt The prompt used in the LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parseResultWithPrompt(generations, _prompt, callbacks) {\n        return this.parseResult(generations, callbacks);\n    }\n    /**\n     * Calls the parser with a given input and optional configuration options.\n     * If the input is a string, it creates a generation with the input as\n     * text and calls `parseResult`. If the input is a `BaseMessage`, it\n     * creates a generation with the input as a message and the content of the\n     * input as text, and then calls `parseResult`.\n     * @param input The input to the parser, which can be a string or a `BaseMessage`.\n     * @param options Optional configuration options.\n     * @returns A promise of the parsed output.\n     */\n    async invoke(input, options) {\n        if (typeof input === \"string\") {\n            return this._callWithConfig(async (input) => this.parseResult([{ text: input }]), input, { ...options, runType: \"parser\" });\n        }\n        else {\n            return this._callWithConfig(async (input) => this.parseResult([\n                {\n                    message: input,\n                    text: typeof input.content === \"string\"\n                        ? input.content\n                        : JSON.stringify(input.content),\n                },\n            ]), input, { ...options, runType: \"parser\" });\n        }\n    }\n}\n/**\n * Class to parse the output of an LLM call.\n */\nexport class BaseOutputParser extends BaseLLMOutputParser {\n    parseResult(generations, callbacks) {\n        return this.parse(generations[0].text, callbacks);\n    }\n    async parseWithPrompt(text, _prompt, callbacks) {\n        return this.parse(text, callbacks);\n    }\n    /**\n     * Return the string type key uniquely identifying this class of parser\n     */\n    _type() {\n        throw new Error(\"_type not implemented\");\n    }\n}\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nexport class OutputParserException extends Error {\n    constructor(message, llmOutput, observation, sendToLLM = false) {\n        super(message);\n        Object.defineProperty(this, \"llmOutput\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sendToLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.llmOutput = llmOutput;\n        this.observation = observation;\n        this.sendToLLM = sendToLLM;\n        if (sendToLLM) {\n            if (observation === undefined || llmOutput === undefined) {\n                throw new Error(\"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\");\n            }\n        }\n    }\n}\n","import { encodePointer } from \"./pointer.js\";\nexport const schemaKeyword = {\n    additionalItems: true,\n    unevaluatedItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    unevaluatedProperties: true,\n    propertyNames: true,\n    not: true,\n    if: true,\n    then: true,\n    else: true,\n};\nexport const schemaArrayKeyword = {\n    prefixItems: true,\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true,\n};\nexport const schemaMapKeyword = {\n    $defs: true,\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    dependentSchemas: true,\n};\nexport const ignoredKeyword = {\n    id: true,\n    $id: true,\n    $ref: true,\n    $schema: true,\n    $anchor: true,\n    $vocabulary: true,\n    $comment: true,\n    default: true,\n    enum: true,\n    const: true,\n    required: true,\n    type: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    multipleOf: true,\n    maxLength: true,\n    minLength: true,\n    pattern: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    uniqueItems: true,\n    maxProperties: true,\n    minProperties: true,\n};\n/**\n * Default base URI for schemas without an $id.\n * https://json-schema.org/draft/2019-09/json-schema-core.html#initial-base\n * https://tools.ietf.org/html/rfc3986#section-5.1\n */\nexport let initialBaseURI = \n// @ts-ignore\ntypeof self !== \"undefined\" && self.location\n    ? //@ts-ignore\n        /* #__PURE__ */ new URL(self.location.origin + self.location.pathname + location.search)\n    : /* #__PURE__ */ new URL(\"https://github.com/cfworker\");\nexport function dereference(schema, lookup = Object.create(null), baseURI = initialBaseURI, basePointer = \"\") {\n    if (schema && typeof schema === \"object\" && !Array.isArray(schema)) {\n        const id = schema.$id || schema.id;\n        if (id) {\n            const url = new URL(id, baseURI.href);\n            if (url.hash.length > 1) {\n                lookup[url.href] = schema;\n            }\n            else {\n                url.hash = \"\"; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n                if (basePointer === \"\") {\n                    baseURI = url;\n                }\n                else {\n                    dereference(schema, lookup, baseURI);\n                }\n            }\n        }\n    }\n    else if (schema !== true && schema !== false) {\n        return lookup;\n    }\n    // compute the schema's URI and add it to the mapping.\n    const schemaURI = baseURI.href + (basePointer ? \"#\" + basePointer : \"\");\n    if (lookup[schemaURI] !== undefined) {\n        throw new Error(`Duplicate schema URI \"${schemaURI}\".`);\n    }\n    lookup[schemaURI] = schema;\n    // exit early if this is a boolean schema.\n    if (schema === true || schema === false) {\n        return lookup;\n    }\n    // set the schema's absolute URI.\n    if (schema.__absolute_uri__ === undefined) {\n        Object.defineProperty(schema, \"__absolute_uri__\", {\n            enumerable: false,\n            value: schemaURI,\n        });\n    }\n    // if a $ref is found, resolve it's absolute URI.\n    if (schema.$ref && schema.__absolute_ref__ === undefined) {\n        const url = new URL(schema.$ref, baseURI.href);\n        url.hash = url.hash; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n        Object.defineProperty(schema, \"__absolute_ref__\", {\n            enumerable: false,\n            value: url.href,\n        });\n    }\n    // if a $recursiveRef is found, resolve it's absolute URI.\n    if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === undefined) {\n        const url = new URL(schema.$recursiveRef, baseURI.href);\n        url.hash = url.hash; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n        Object.defineProperty(schema, \"__absolute_recursive_ref__\", {\n            enumerable: false,\n            value: url.href,\n        });\n    }\n    // if an $anchor is found, compute it's URI and add it to the mapping.\n    if (schema.$anchor) {\n        const url = new URL(\"#\" + schema.$anchor, baseURI.href);\n        lookup[url.href] = schema;\n    }\n    // process subschemas.\n    for (let key in schema) {\n        if (ignoredKeyword[key]) {\n            continue;\n        }\n        const keyBase = `${basePointer}/${encodePointer(key)}`;\n        const subSchema = schema[key];\n        if (Array.isArray(subSchema)) {\n            if (schemaArrayKeyword[key]) {\n                const length = subSchema.length;\n                for (let i = 0; i < length; i++) {\n                    dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);\n                }\n            }\n        }\n        else if (schemaMapKeyword[key]) {\n            for (let subKey in subSchema) {\n                dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${encodePointer(subKey)}`);\n            }\n        }\n        else {\n            dereference(subSchema, lookup, baseURI, keyBase);\n        }\n    }\n    return lookup;\n}\n// schema identification examples\n// https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.appendix.A\n// $ref delegation\n// https://github.com/json-schema-org/json-schema-spec/issues/514\n// output format\n// https://json-schema.org/draft/2019-09/json-schema-core.html#output\n// JSON pointer\n// https://tools.ietf.org/html/rfc6901\n// JSON relative pointer\n// https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01\n","import { BaseOutputParser } from \"../schema/output_parser.js\";\n/**\n * The NoOpOutputParser class is a type of output parser that does not\n * perform any operations on the output. It extends the BaseOutputParser\n * class and is part of the LangChain's output parsers module. This class\n * is useful in scenarios where the raw output of the Large Language\n * Models (LLMs) is required.\n */\nexport class NoOpOutputParser extends BaseOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"default\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"NoOpOutputParser\";\n    }\n    /**\n     * This method takes a string as input and returns the same string as\n     * output. It does not perform any operations on the input string.\n     * @param text The input string to be parsed.\n     * @returns The same input string without any operations performed on it.\n     */\n    parse(text) {\n        return Promise.resolve(text);\n    }\n    /**\n     * This method returns an empty string. It does not provide any formatting\n     * instructions.\n     * @returns An empty string, indicating no formatting instructions.\n     */\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n","import { BaseLanguageModel, } from \"@langchain/core/language_models/base\";\nimport { BaseChain } from \"./base.js\";\nimport { BasePromptTemplate } from \"../prompts/base.js\";\nimport { NoOpOutputParser } from \"../output_parsers/noop.js\";\nimport { Runnable } from \"../schema/runnable/base.js\";\nfunction isBaseLanguageModel(llmLike) {\n    return typeof llmLike._llmType === \"function\";\n}\nfunction _getLanguageModel(llmLike) {\n    if (isBaseLanguageModel(llmLike)) {\n        return llmLike;\n    }\n    else if (\"bound\" in llmLike && Runnable.isRunnable(llmLike.bound)) {\n        return _getLanguageModel(llmLike.bound);\n    }\n    else if (\"runnable\" in llmLike &&\n        \"fallbacks\" in llmLike &&\n        Runnable.isRunnable(llmLike.runnable)) {\n        return _getLanguageModel(llmLike.runnable);\n    }\n    else if (\"default\" in llmLike && Runnable.isRunnable(llmLike.default)) {\n        return _getLanguageModel(llmLike.default);\n    }\n    else {\n        throw new Error(\"Unable to extract BaseLanguageModel from llmLike object.\");\n    }\n}\n/**\n * Chain to run queries against LLMs.\n *\n * @example\n * ```ts\n * import { LLMChain } from \"langchain/chains\";\n * import { OpenAI } from \"langchain/llms/openai\";\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = PromptTemplate.fromTemplate(\"Tell me a {adjective} joke\");\n * const llm = new LLMChain({ llm: new OpenAI(), prompt });\n * ```\n */\nexport class LLMChain extends BaseChain {\n    static lc_name() {\n        return \"LLMChain\";\n    }\n    get inputKeys() {\n        return this.prompt.inputVariables;\n    }\n    get outputKeys() {\n        return [this.outputKey];\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"prompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"llm\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"llmKwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"text\"\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.prompt = fields.prompt;\n        this.llm = fields.llm;\n        this.llmKwargs = fields.llmKwargs;\n        this.outputKey = fields.outputKey ?? this.outputKey;\n        this.outputParser =\n            fields.outputParser ?? new NoOpOutputParser();\n        if (this.prompt.outputParser) {\n            if (fields.outputParser) {\n                throw new Error(\"Cannot set both outputParser and prompt.outputParser\");\n            }\n            this.outputParser = this.prompt.outputParser;\n        }\n    }\n    getCallKeys() {\n        const callKeys = \"callKeys\" in this.llm ? this.llm.callKeys : [];\n        return callKeys;\n    }\n    /** @ignore */\n    _selectMemoryInputs(values) {\n        const valuesForMemory = super._selectMemoryInputs(values);\n        const callKeys = this.getCallKeys();\n        for (const key of callKeys) {\n            if (key in values) {\n                delete valuesForMemory[key];\n            }\n        }\n        return valuesForMemory;\n    }\n    /** @ignore */\n    async _getFinalOutput(generations, promptValue, runManager) {\n        let finalCompletion;\n        if (this.outputParser) {\n            finalCompletion = await this.outputParser.parseResultWithPrompt(generations, promptValue, runManager?.getChild());\n        }\n        else {\n            finalCompletion = generations[0].text;\n        }\n        return finalCompletion;\n    }\n    /**\n     * Run the core logic of this chain and add to output if desired.\n     *\n     * Wraps _call and handles memory.\n     */\n    call(values, config) {\n        return super.call(values, config);\n    }\n    /** @ignore */\n    async _call(values, runManager) {\n        const valuesForPrompt = { ...values };\n        const valuesForLLM = {\n            ...this.llmKwargs,\n        };\n        const callKeys = this.getCallKeys();\n        for (const key of callKeys) {\n            if (key in values) {\n                if (valuesForLLM) {\n                    valuesForLLM[key] =\n                        values[key];\n                    delete valuesForPrompt[key];\n                }\n            }\n        }\n        const promptValue = await this.prompt.formatPromptValue(valuesForPrompt);\n        if (\"generatePrompt\" in this.llm) {\n            const { generations } = await this.llm.generatePrompt([promptValue], valuesForLLM, runManager?.getChild());\n            return {\n                [this.outputKey]: await this._getFinalOutput(generations[0], promptValue, runManager),\n            };\n        }\n        const modelWithParser = this.outputParser\n            ? this.llm.pipe(this.outputParser)\n            : this.llm;\n        const response = await modelWithParser.invoke(promptValue, runManager?.getChild());\n        return {\n            [this.outputKey]: response,\n        };\n    }\n    /**\n     * Format prompt with values and pass to LLM\n     *\n     * @param values - keys to pass to prompt template\n     * @param callbackManager - CallbackManager to use\n     * @returns Completion from LLM.\n     *\n     * @example\n     * ```ts\n     * llm.predict({ adjective: \"funny\" })\n     * ```\n     */\n    async predict(values, callbackManager) {\n        const output = await this.call(values, callbackManager);\n        return output[this.outputKey];\n    }\n    _chainType() {\n        return \"llm\";\n    }\n    static async deserialize(data) {\n        const { llm, prompt } = data;\n        if (!llm) {\n            throw new Error(\"LLMChain must have llm\");\n        }\n        if (!prompt) {\n            throw new Error(\"LLMChain must have prompt\");\n        }\n        return new LLMChain({\n            llm: await BaseLanguageModel.deserialize(llm),\n            prompt: await BasePromptTemplate.deserialize(prompt),\n        });\n    }\n    /** @deprecated */\n    serialize() {\n        const serialize = \"serialize\" in this.llm ? this.llm.serialize() : undefined;\n        return {\n            _type: `${this._chainType()}_chain`,\n            llm: serialize,\n            prompt: this.prompt.serialize(),\n        };\n    }\n    _getNumTokens(text) {\n        return _getLanguageModel(this.llm).getNumTokens(text);\n    }\n}\n"],"names":["BasePromptTemplate","lc_attributes","partialVariables","undefined","constructor","input","super","Object","defineProperty","this","enumerable","configurable","writable","value","_getPromptType","inputVariables","includes","Error","assign","mergePartialAndUserVariables","userVariables","partialValues","key","entries","invoke","options","_callWithConfig","formatPromptValue","runType","serialize","deserialize","data","_type","PromptTemplate","FewShotPromptTemplate","lc_name","validateTemplate","totalInputVariables","concat","keys","template","templateFormat","format","values","allValues","fromExamples","examples","suffix","exampleSeparator","prefix","join","fromTemplate","rest","names","Set","forEach","node","type","add","name","partial","newInputVariables","filter","iv","newPartialVariables","promptDict","outputParser","input_variables","template_format","BaseStringPromptTemplate","formattedPrompt","parseFString","chars","split","nodes","nextBracket","bracket","start","i","length","push","text","j","slice","next","DEFAULT_FORMATTER_MAPPING","reduce","res","DEFAULT_PARSER_MAPPING","renderTemplate","inputValues","parseTemplate","checkValidTemplate","validFormats","dummyInputs","acc","v","e","message","BasePromptSelector","getPromptAsync","llm","getPrompt","ConditionalPromptSelector","default_prompt","conditionals","defaultPrompt","condition","prompt","isChatModel","_modelType","BaseLLMOutputParser","parseResultWithPrompt","generations","_prompt","callbacks","parseResult","async","content","JSON","stringify","parse","parseWithPrompt","self","location","origin","pathname","search","NoOpOutputParser","arguments","Promise","resolve","getFormatInstructions","_getLanguageModel","llmLike","_llmType","isBaseLanguageModel","isRunnable","bound","runnable","default","LLMChain","inputKeys","outputKeys","outputKey","fields","llmKwargs","getCallKeys","callKeys","_selectMemoryInputs","valuesForMemory","_getFinalOutput","promptValue","runManager","finalCompletion","getChild","call","config","_call","valuesForPrompt","valuesForLLM","generatePrompt","modelWithParser","pipe","response","predict","callbackManager","_chainType","_getNumTokens","getNumTokens"],"sourceRoot":""}