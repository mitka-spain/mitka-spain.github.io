{"version":3,"file":"557.js","mappings":"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","sources":["webpack://inqviz-excel/./node_modules/@langchain/core/dist/prompts/base.js","webpack://inqviz-excel/./node_modules/@langchain/core/dist/prompts/prompt.js","webpack://inqviz-excel/./node_modules/@langchain/core/dist/prompts/string.js","webpack://inqviz-excel/./node_modules/@langchain/core/dist/prompts/template.js"],"sourcesContent":["// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { Runnable } from \"../runnables/base.js\";\n/**\n * Base class for prompt templates. Exposes a format method that returns a\n * string prompt given a set of input values.\n */\nexport class BasePromptTemplate extends Runnable {\n    get lc_attributes() {\n        return {\n            partialVariables: undefined, // python doesn't support this yet\n        };\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompts\", this._getPromptType()]\n        });\n        Object.defineProperty(this, \"inputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"partialVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const { inputVariables } = input;\n        if (inputVariables.includes(\"stop\")) {\n            throw new Error(\"Cannot have an input variable named 'stop', as it is used internally, please rename.\");\n        }\n        Object.assign(this, input);\n    }\n    /**\n     * Merges partial variables and user variables.\n     * @param userVariables The user variables to merge with the partial variables.\n     * @returns A Promise that resolves to an object containing the merged variables.\n     */\n    async mergePartialAndUserVariables(userVariables) {\n        const partialVariables = this.partialVariables ?? {};\n        const partialValues = {};\n        for (const [key, value] of Object.entries(partialVariables)) {\n            if (typeof value === \"string\") {\n                partialValues[key] = value;\n            }\n            else {\n                partialValues[key] = await value();\n            }\n        }\n        const allKwargs = {\n            ...partialValues,\n            ...userVariables,\n        };\n        return allKwargs;\n    }\n    /**\n     * Invokes the prompt template with the given input and options.\n     * @param input The input to invoke the prompt template with.\n     * @param options Optional configuration for the callback.\n     * @returns A Promise that resolves to the output of the prompt template.\n     */\n    async invoke(input, options) {\n        return this._callWithConfig((input) => this.formatPromptValue(input), input, { ...options, runType: \"prompt\" });\n    }\n    /**\n     * Return a json-like object representing this prompt template.\n     * @deprecated\n     */\n    serialize() {\n        throw new Error(\"Use .toJSON() instead\");\n    }\n    /**\n     * @deprecated\n     * Load a prompt template from a json-like object describing it.\n     *\n     * @remarks\n     * Deserializing needs to be async because templates (e.g. {@link FewShotPromptTemplate}) can\n     * reference remote resources that we read asynchronously with a web\n     * request.\n     */\n    static async deserialize(data) {\n        switch (data._type) {\n            case \"prompt\": {\n                const { PromptTemplate } = await import(\"./prompt.js\");\n                return PromptTemplate.deserialize(data);\n            }\n            case undefined: {\n                const { PromptTemplate } = await import(\"./prompt.js\");\n                return PromptTemplate.deserialize({ ...data, _type: \"prompt\" });\n            }\n            case \"few_shot\": {\n                const { FewShotPromptTemplate } = await import(\"./few_shot.js\");\n                return FewShotPromptTemplate.deserialize(data);\n            }\n            default:\n                throw new Error(`Invalid prompt type in config: ${data._type}`);\n        }\n    }\n}\n","// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport { checkValidTemplate, parseTemplate, renderTemplate, } from \"./template.js\";\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate extends BaseStringPromptTemplate {\n    static lc_name() {\n        return \"PromptTemplate\";\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"template\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.assign(this, input);\n        if (this.validateTemplate) {\n            let totalInputVariables = this.inputVariables;\n            if (this.partialVariables) {\n                totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n            }\n            checkValidTemplate(this.template, this.templateFormat, totalInputVariables);\n        }\n    }\n    _getPromptType() {\n        return \"prompt\";\n    }\n    /**\n     * Formats the prompt template with the provided values.\n     * @param values The values to be used to format the prompt template.\n     * @returns A promise that resolves to a string which is the formatted prompt.\n     */\n    async format(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        return renderTemplate(this.template, this.templateFormat, allValues);\n    }\n    /**\n     * Take examples in list format with prefix and suffix to create a prompt.\n     *\n     * Intended to be used a a way to dynamically create a prompt from examples.\n     *\n     * @param examples - List of examples to use in the prompt.\n     * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n     * @param inputVariables - A list of variable names the final prompt template will expect\n     * @param exampleSeparator - The separator to use in between examples\n     * @param prefix - String that should go before any examples. Generally includes examples.\n     *\n     * @returns The final prompt template generated.\n     */\n    static fromExamples(examples, suffix, inputVariables, exampleSeparator = \"\\n\\n\", prefix = \"\") {\n        const template = [prefix, ...examples, suffix].join(exampleSeparator);\n        return new PromptTemplate({\n            inputVariables,\n            template,\n        });\n    }\n    /**\n     * Load prompt template from a template f-string\n     */\n    static fromTemplate(template, { templateFormat = \"f-string\", ...rest } = {}) {\n        const names = new Set();\n        parseTemplate(template, templateFormat).forEach((node) => {\n            if (node.type === \"variable\") {\n                names.add(node.name);\n            }\n        });\n        return new PromptTemplate({\n            // Rely on extracted types\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            inputVariables: [...names],\n            templateFormat,\n            template,\n            ...rest,\n        });\n    }\n    /**\n     * Partially applies values to the prompt template.\n     * @param values The values to be partially applied to the prompt template.\n     * @returns A new instance of PromptTemplate with the partially applied values.\n     */\n    async partial(values) {\n        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        const newPartialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        const promptDict = {\n            ...this,\n            inputVariables: newInputVariables,\n            partialVariables: newPartialVariables,\n        };\n        return new PromptTemplate(promptDict);\n    }\n    serialize() {\n        if (this.outputParser !== undefined) {\n            throw new Error(\"Cannot serialize a prompt template with an output parser\");\n        }\n        return {\n            _type: this._getPromptType(),\n            input_variables: this.inputVariables,\n            template: this.template,\n            template_format: this.templateFormat,\n        };\n    }\n    static async deserialize(data) {\n        if (!data.template) {\n            throw new Error(\"Prompt template must have a template\");\n        }\n        const res = new PromptTemplate({\n            inputVariables: data.input_variables,\n            template: data.template,\n            templateFormat: data.template_format,\n        });\n        return res;\n    }\n}\n","// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { StringPromptValue, } from \"../prompt_values.js\";\nimport { BasePromptTemplate } from \"./base.js\";\n/**\n * Base class for string prompt templates. It extends the\n * BasePromptTemplate class and overrides the formatPromptValue method to\n * return a StringPromptValue.\n */\nexport class BaseStringPromptTemplate extends BasePromptTemplate {\n    /**\n     * Formats the prompt given the input values and returns a formatted\n     * prompt value.\n     * @param values The input values to format the prompt.\n     * @returns A Promise that resolves to a formatted prompt value.\n     */\n    async formatPromptValue(values) {\n        const formattedPrompt = await this.format(values);\n        return new StringPromptValue(formattedPrompt);\n    }\n}\n","export const parseFString = (template) => {\n    // Core logic replicated from internals of pythons built in Formatter class.\n    // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n    const chars = template.split(\"\");\n    const nodes = [];\n    const nextBracket = (bracket, start) => {\n        for (let i = start; i < chars.length; i += 1) {\n            if (bracket.includes(chars[i])) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    let i = 0;\n    while (i < chars.length) {\n        if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n            nodes.push({ type: \"literal\", text: \"{\" });\n            i += 2;\n        }\n        else if (chars[i] === \"}\" &&\n            i + 1 < chars.length &&\n            chars[i + 1] === \"}\") {\n            nodes.push({ type: \"literal\", text: \"}\" });\n            i += 2;\n        }\n        else if (chars[i] === \"{\") {\n            const j = nextBracket(\"}\", i);\n            if (j < 0) {\n                throw new Error(\"Unclosed '{' in template.\");\n            }\n            nodes.push({\n                type: \"variable\",\n                name: chars.slice(i + 1, j).join(\"\"),\n            });\n            i = j + 1;\n        }\n        else if (chars[i] === \"}\") {\n            throw new Error(\"Single '}' in template.\");\n        }\n        else {\n            const next = nextBracket(\"{}\", i);\n            const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n            nodes.push({ type: \"literal\", text });\n            i = next < 0 ? chars.length : next;\n        }\n    }\n    return nodes;\n};\nexport const interpolateFString = (template, values) => parseFString(template).reduce((res, node) => {\n    if (node.type === \"variable\") {\n        if (node.name in values) {\n            return res + values[node.name];\n        }\n        throw new Error(`Missing value for input ${node.name}`);\n    }\n    return res + node.text;\n}, \"\");\nexport const DEFAULT_FORMATTER_MAPPING = {\n    \"f-string\": interpolateFString,\n};\nexport const DEFAULT_PARSER_MAPPING = {\n    \"f-string\": parseFString,\n};\nexport const renderTemplate = (template, templateFormat, inputValues) => DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\nexport const parseTemplate = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);\nexport const checkValidTemplate = (template, templateFormat, inputVariables) => {\n    if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n        const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n        throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n    }\n    try {\n        const dummyInputs = inputVariables.reduce((acc, v) => {\n            acc[v] = \"foo\";\n            return acc;\n        }, {});\n        renderTemplate(template, templateFormat, dummyInputs);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }\n    catch (e) {\n        throw new Error(`Invalid prompt schema: ${e.message}`);\n    }\n};\n"],"names":["BasePromptTemplate","lc_attributes","partialVariables","undefined","constructor","input","super","Object","defineProperty","this","enumerable","configurable","writable","value","_getPromptType","inputVariables","includes","Error","assign","mergePartialAndUserVariables","userVariables","partialValues","key","entries","invoke","options","_callWithConfig","formatPromptValue","runType","serialize","deserialize","data","_type","PromptTemplate","FewShotPromptTemplate","lc_name","validateTemplate","totalInputVariables","concat","keys","template","templateFormat","format","values","allValues","fromExamples","examples","suffix","exampleSeparator","prefix","join","fromTemplate","rest","names","Set","forEach","node","type","add","name","partial","newInputVariables","filter","iv","newPartialVariables","promptDict","outputParser","input_variables","template_format","BaseStringPromptTemplate","formattedPrompt","parseFString","chars","split","nodes","nextBracket","bracket","start","i","length","push","text","j","slice","next","DEFAULT_FORMATTER_MAPPING","reduce","res","DEFAULT_PARSER_MAPPING","renderTemplate","inputValues","parseTemplate","checkValidTemplate","validFormats","dummyInputs","acc","v","e","message"],"sourceRoot":""}